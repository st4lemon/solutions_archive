"""

https://codeforces.com/gym/104945/problem/H
2023-2024 ICPC Southwestern European Regional Contest (SWERC 2023) #H: Break a leg!

Problem:
Your job is to build a table. The top surface of the table is already built; it has constant width and uniform density, and can be represented by the interior of a non-crossing polygon in the plane, of which no three vertices are collinear. You have three table legs of the same length and negligible width, and you wish to place them on distinct corners (vertices) of the table such that the table remains standing when standing on these legs. In other words, you must choose three vertices such that the center of gravity of the polygon lies in the interior of the triangle formed by these vertices. 

In how many ways can you do this? If two ways of placing legs differ only by a permutation of the legs, they are not counted as different ways.
 - 3 <= N <= 100,000 vertices describing the polygon. Consecutive vertices describe line segments of the polygon.
 - For each point (x, y): -1,000,000 <= x, y <= 1,000,000


Solution: 
First, let's think about how to find the center of mass. Reasonbly it seems like this would be helpful for determining if a table falls over or not; if we know the center of mass then for a given triplet of legs we just have to check if the center of mass is inside the triangle formed by the legs. 

The integral derivation for center of mass for a surface of uniform density can be found with two integrals: taking the surface integral of x dA and y dA over the entire surface to find the x-position and y-position respectively. However, it is not straightforward to calculate this integral directly; the shape can be very complex (ex: a spiral-shaped polygon is not easy to evaluate). 

What we instead do is to use a signed triangulation of the entire polygon, where we essentially fix one point, and for every line segment of the polygon we compute the signed area that it forms with the chosen point. The signed area is important because the center of mass calculation is calculated with an integral, therefore we can subtract parts that we originally added in order to capture a complex shape. We can get signed area by leaving the sign of the cross product in our area formula; the area will be positive or negative depending on the orientation of the line segment with respect to our first fixed point. In my code, I fix pts[0] as the fixed point, and the rest of the line segments form a signed triangulation of the polygon. 

It is also well known that the center of mass of a triangle is its centroid (intersection of its three medians), which can be calculated by averaging the three vertices. This then removes the requirement to compute an integral; we simply compute the center of mass and multiply it by the area of the triangle to obtain its contribution to the overall center of mass of the polygon. Adding the weighted center of masses together over all triangles (with respect to signed area) produces a number equal to the center of mass multiplied by the total area of the polygon. The actual center of mass is easily obtainable from this. 

Then, once we have the center of mass it remains to determine which triplets of vertices contain the center of mass. Note that the table is still considered unstable if the center of mass lies on an edge (the first provided sample test case is a square and has 0 stable configurations, for example). I found it easier to calculate the number of triangles that don't contain the center of mass instead; if we draw a line through the the center of mass, then choosing any three points on one side of the line forms a triangle not containing the center of mass. This is far easier than checking triangles individually, which seems to be necessary if we directly count the triangles. 

We use the drawing lines method to count such triangles. I chose to do this by drawing a line for each vertex, and then counting how many ways to choose two points from the "right" side of the line (if we face the center of mass, all points on the right from the current vertex). This counts each triangle once; for any triangle all points are on the right side of the line for exactly one of the lines generated by the triangle's vertices. We find what points are on the right side of the line by first sorting all lines by their angle relative to the center of mass, and then binary searching for the last point which is still on the right side of the line. It does not matter what order the points appear in the input; just what side of the line the points are on. 

The final solution (before bug fixes) is:
- Use signed triangulation to compute center of mass
- Sort points by angle relative to center of mass
- Iterate over points and count how many are on right side of line. Compute number of unstable triangles from this count.
- Subtract unstable triangles from N choose 3 for the final answer



Since this is computational geometry, we need to consider all edge cases, including precision issues. 


Issues with double precision: if the center of mass is not exact, we will easily miscount the number of triangles. When calculating the center of mass, we divide by 2 for the area, divide by 3 for calculating centroids, and divide by the total area when computing the final center. This turns out to just be a rational number, so we can instead just keep everything as an integer and skip dividing at all steps of the process, then we can scale all points by 6*area at the end of the process to ensure the center of mass can be represented by integer coordinates and it is representative of the points. I chose to use Python for arbitrary integer precision, because this will overflow a 64 bit signed integer if I use C++. 

Also, since the coordinates are integral with magnitude < 10^6, there is enough precision to simply sort points by using atan2 (10^-12 >>> 1e-16). 


Points with same angle: We are guaranteed no three points are collinear, so these will always form triangles; we also still want both of them to interact with other points so removing them is not an (easy) option. Since we sort all the points, one point will still appear before the other in the sorted list, so only one of the points will actually count triangles including the other point. No need to worry about this. 


Edge case: If the center of mass lies on an edge, all the calculations for angles still work just fine. It is also necessary to ensure that, when we compute points on the right side of the line, that we include points that lie on the line (which is why the binary search contains <= 0 in the if-condition)


Corner case: If the center of mass lies on a vertex, then the cross product always evaluates to 0 at that point. This improperly computes that all points lie on the right side of its line. Such a point can never be part of a triangle, therefore after calculating center of mass, we can simply remove this point before starting to count triangles. 



"""

from math import atan2

N = int(input())

pts = []

for i in range(N):
    a, b = map(int, input().split())
    pts.append((a, b))


def cross(a, b):
    # print(a, b, a[0]*b[1] - a[1]*b[0])
    return a[0]*b[1] - a[1]*b[0]


def add(a, b):
    return a[0] + b[0], a[1] + b[1]


def scalar_mult(a, b):
    return a * b[0], a * b[1]


def sub(a, b):
    return a[0] - b[0], a[1] - b[1]


def mid(a, b, c):  # returns 3*midpoint
    return b[0]+a[0]+c[0], b[1]+a[1]+c[1]


def area(a, b, c):  # returns 2*area
    return cross(sub(b, a), sub(c, a))


total_area = 0  # 2 times actual area
total_center = (0, 0)  # 6 times actual center * area

for i in range(1, N-1):
    a = area(pts[0], pts[i], pts[i+1])
    c = mid(pts[0], pts[i], pts[i+1])
    total_area += a
    total_center = add(total_center, scalar_mult(a, c))

# print(total_area)
# print(total_center)

for i in range(N):
    pts[i] = scalar_mult(total_area*3, pts[i])

if pts.count(total_center) > 0:
    pts.remove(total_center)
    N -= 1

# print(pts)

# sort pts by angle?

pts.sort(key=lambda x: atan2(total_center[1] - x[1], total_center[0] - x[0]))

# print(pts)


ans = N * (N-1) * (N-2) // 6  # 3 choose 6

for i in range(N):
    # find last one to the left/on center dot
    low = 0
    high = N-1
    while low < high:
        m = (low + high + 1) // 2
        md = (m + i) % N
        # print(low, high, mid)
        if cross(sub(total_center, pts[i]), sub(pts[md], pts[i])) <= 0:
            low = m
        else:
            high = m - 1
    ans -= low * (low-1) // 2
    # (i, ": ", low,  ans)

print(ans)


